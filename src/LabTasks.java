import java.math.BigInteger;
import java.nio.charset.StandardCharsets;

public class LabTasks {

    public static void main(final String... theArgs) {

        /* 3.1 Task 1: Deriving the Private Key */

        BigInteger p = new BigInteger("F7E75FDC469067FFDC4E847C51F452DF", 16);
        BigInteger q = new BigInteger("E85CED54AF57E53E092113E62F436F4F", 16);
        //public modulus p * q
        BigInteger n = new BigInteger("DCBFFE3E51F62E09CE7032E2677A78946A849DC4CDDE3A4D0CB81629242FB1A5", 16);
        BigInteger e = new BigInteger("0D88C3", 16);

        BigInteger phi_n = p.subtract(BigInteger.ONE).multiply(q.subtract(BigInteger.ONE));
        BigInteger d = e.modInverse(phi_n);

        System.out.println("Euler's totient function for this p and q is: " +  phi_n + "\n");
        System.out.println("Private key d is: " +  d + "\n");

        /* 3.2 Task 2: Encrypting a message  */

        //Hex value for the string "A top secret!"
        BigInteger M = new BigInteger("4120746f702073656372657421", 16);

        //Public Key
        e = new BigInteger("010001", 16);

        BigInteger cipher_text = M.modPow(e, n);
        System.out.println("Ciphertext: " +  cipher_text  + "\n");


        //decrypt using provided key to verify result:
        d = new BigInteger("74D806F9F3A62BAE331FFE3F0A68AFE35B3D2E4794148AACBC26AA381CD7D30D",16);

        BigInteger plaintext = cipher_text.modPow(d, n);
        System.out.println("Plaintext: " + plaintext + "\n");


        /* 3.3 Task 3: Decrypting a message */

        //Some arbitrary ciphertext
        BigInteger c = new BigInteger("74D806F9F3A62BAE331FFE3F0A68AFE35B3D2E4794148AACBC26AA381CD7D30D", 16);
        plaintext = c.modPow(d, n);
        System.out.println("Plaintext: " + plaintext + "\n");

        /* 3.4 Task 4: Signing a message  */

        //Hex for string: "I owe you $2000."
        M = new BigInteger("49206f776520796f752024323030302e", 16);

        //Signature of message is generated by the same process as decryption:
        BigInteger S = M.modPow(d, n);
        System.out.println("Signature of M under key d: " + S + "\n");

        //Hex for string: "I owe you $3000."
        M = new BigInteger("49206f776520796f75202433303030", 16);

        S = M.modPow(d, n);
        System.out.println("Signature of M` under key d: " + S + "\n");

        /* 3.5 Task 5: Verifying a Signature */

        n = new BigInteger("AE1CD4DC432798D933779FBD46C6E1247F0CF1233595113AA51B450F18116115", 16);

        //hex value for string: "Launch a missle."
        M = new BigInteger("4c61756e63682061206d697373696c652e", 16);
        //Alleged signature of M under Alice's private key
        S = new BigInteger("643D6F34902D9C7EC90CB0B2BCA36C47FA37165C0005CAB026C0542CBDB6802F", 16);
        e = new BigInteger("010001", 16);

        //Verify signature by S to Alice's publick key mod n, if the result = M then success, failure otherwise.
        BigInteger verify = S.modPow(e, n);
        System.out.println("Result of verification procedure: " + verify + "\n");

        //Change the last byte of the signature to introduce corruption
        S = new BigInteger("643D6F34902D9C7EC90CB0B2BCA36C47FA37165C0005CAB026C0542CBDB6803F", 16);

        verify = S.modPow(e, n);
        System.out.println("Result of verification procedure on corrupted signature: " + verify + "\n");

        /* 3.6 Task 6: Manually Verifying an X.509 Certificate */

        e = new BigInteger("10001", 16);

        n = new BigInteger("BB021528CCF6A094D30F12EC8D5592C3F882F199A67A4288A75D26AAB52BB9C54CB1AF8E6BF975C8A3D70F4794145535578C9EA8A23919F5823C42A94E6EF53BC32EDB8DC0B05CF35938E7EDCF69F05A0B1BBEC094242587FA3771B313E71CACE19BEFDBE43B45524596A9C153CE34C852EEB5AEED8FDE6070E2A554ABB66D0E97A540346B2BD3BC66EB66347CFA6B8B8F572999F830175DBA726FFB81C5ADD286583D17C7E709BBF12BF786DCC1DA715DD446E3CCAD25C188BC60677566B3F118F7A25CE653FF3A88B647A5FF1318EA9809773F9D53F9CF01E5F5A6701714AF63A4FF99B3939DDC53A706FE48851DA169AE2575BB13CC5203F5ED51A18BDB15", 16);

        M = new BigInteger("707d5952feb773cf0c6bce0d040f42da073443aded828a311e8e0ea108857e90", 16);

        S = new BigInteger( "6e0e3157bde405d0ac6a2812e7508d63c9d8"+
                                "5c7a2ca6c9409c2ae959dbe432876bf05664"+
                                "db88c37fa2c9006631af8b95479b88c7a389"+
                                "2fba4e5d967d5d202151d042fa8f68c9f703"+
                                "b47b95819748db7ce17ac6ba4ada023c5de1"+
                                "3c28139dfcdf558ee38fd0954998591b75eb"+
                                "4aa4a8a84cb944c040a204e630fb9297fd72"+
                                "386b61fa7312b89c6e5413e952232f759607"+
                                "2273640db2bdc43d09da2f60438f83590d09"+
                                "4548de85cd525994025e0f6d49b435246627"+
                                "69d1f5f4491c4b05e38a8e5b7f5adfb022a5"+
                                "7bfb97d2dc1509e8a8cd147e268e2dd07489"+
                                "a83294be06cedc3249efcac79f26b530b082"+
                                "bdb8597d0fbc1406747ecff6e5a840c35cb6"+
                                "ba07299c",16);


        verify = S.modPow(e, n);

        System.out.println("Result of verification against imported certificate data: " + verify + "\n");




    }   
}
